// Package parser is responsible for generating an AST from a list of tokens provided by the Lexer in the lexer package.
package parser

import (
	"fmt"

	"github.com/pszponder/json-linter_go/internal/lexer"
)

// ASTNode represents a node in the Abstract Syntax Tree
type ASTNode struct {
	Type     string
	Value    interface{}
	Children []*ASTNode
}

// ParseJSON parses the tokens generated by the lexer and returns the root node of the AST
func ParseJSON(tokens []lexer.Token) (*ASTNode, error) {
	if len(tokens) == 0 {
		return nil, fmt.Errorf("No Tokens provided")
	}

	// idx tracks current position in slice of tokens being parsed.
	// Pass a reference to this index to parseObject & parseArray
	// to make sure that the same index is updated.
	idx := 0

	// 1st Token must be { or [ to be valid JSON
	switch tokens[idx].TokType {
	case lexer.LBRACE:
		rootNode, err := parseObject(tokens, &idx)
		if err != nil {
			return nil, err
		}
		return rootNode, nil
	case lexer.LBRACKET:
		rootNode, err := parseArray(tokens, &idx)
		if err != nil {
			return nil, err
		}
		return rootNode, nil
	default:
		return nil, fmt.Errorf("Invalid top-level construct in JSON at Line %d, Column %d", tokens[0].TokPos.Line, tokens[0].TokPos.ColStart)
	}
}

// expectedToken checks if the current token has the expected type and returns an error if not
func expectedToken(tokens []lexer.Token, index int, expectedType lexer.TokenType, errorMsg string) error {
	if tokens[index].TokType != expectedType {
		return fmt.Errorf("%s at line %d, Column %d:%d",
			errorMsg, tokens[index].TokPos.Line, tokens[index].TokPos.ColStart, tokens[index].TokPos.ColEnd)
	}
	return nil
}

// parseObject parses a JSON object and returns its AST Representation
func parseObject(tokens []lexer.Token, index *int) (*ASTNode, error) {
	objectNode := &ASTNode{Type: "Object", Children: []*ASTNode{}}

	// Consume '{'
	*index++

	// Iterate through tokens until we hit the closing brace
	for tokens[*index].TokType != lexer.RBRACE {
		// Parse key
		if err := expectedToken(tokens, *index, lexer.STR, "Invalid JSON key"); err != nil {
			return nil, err
		}
		keyNode := &ASTNode{Type: "Key", Value: tokens[*index].Lexeme}
		*index++

		// Consume ':'
		if err := expectedToken(tokens, *index, lexer.COLON, "Invalid JSON, expected ':'"); err != nil {
			return nil, err
		}
		*index++

		// Parse value
		valueNode, err := parseValue(tokens, index)
		if err != nil {
			return nil, err
		}

		// Add key-value pair to object
		objectNode.Children = append(objectNode.Children, keyNode, valueNode)

		// Check for trailing commas at end of object
		if tokens[*index].TokType == lexer.COMMA && tokens[*index+1].TokType == lexer.RBRACE {
			return nil, fmt.Errorf("Invalid JSON Object, trailing comma not allowed at Line %d, Column %d:%d", tokens[*index].TokPos.Line, tokens[*index].TokPos.ColStart, tokens[*index].TokPos.ColEnd)
		}

		// If there's a comma, consume it
		if tokens[*index].TokType == lexer.COMMA {
			*index++
		}
	}

	// Consume '}'
	*index++

	return objectNode, nil
}

// parseArray parses a JSON array and returns its AST representation.
func parseArray(tokens []lexer.Token, index *int) (*ASTNode, error) {
	arrayNode := &ASTNode{Type: "Array", Children: []*ASTNode{}}

	// Consume '['
	*index++

	// Iterate through tokens until we hit the closing bracket
	for tokens[*index].TokType != lexer.RBRACKET {
		// Parse array element
		elementNode, err := parseValue(tokens, index)
		if err != nil {
			return nil, err
		}

		// Add element to array
		arrayNode.Children = append(arrayNode.Children, elementNode)

		// Check for trailing commas at end of array
		if tokens[*index].TokType == lexer.COMMA && tokens[*index+1].TokType == lexer.RBRACKET {
			return nil, fmt.Errorf("Invalid JSON Array, trailing comma not allowed at Line %d, Column %d:%d", tokens[*index].TokPos.Line, tokens[*index].TokPos.ColStart, tokens[*index].TokPos.ColEnd)
		}

		// If there's a comma, consume it
		if tokens[*index].TokType == lexer.COMMA {
			*index++
		}
	}

	// Consume ']'
	*index++

	return arrayNode, nil
}

// parseValue parses a JSON value and returns its AST Representation
func parseValue(tokens []lexer.Token, index *int) (*ASTNode, error) {
	valueNode := &ASTNode{Type: "Value"}

	switch tokens[*index].TokType {
	case lexer.LBRACE:
		// Object
		var err error
		valueNode, err = parseObject(tokens, index)
		if err != nil {
			return nil, err
		}
	case lexer.LBRACKET:
		// Array
		var err error
		valueNode, err = parseArray(tokens, index)
		if err != nil {
			return nil, err
		}
	case lexer.STR, lexer.NUM, lexer.TRUE, lexer.FALSE, lexer.NULL:
		// String, Number, True, False, Null
		valueNode.Value = tokens[*index].Lexeme
		*index++
	default:
		// Default case for unknown token types
		return nil, fmt.Errorf("Invalid JSON value '%v' at line %d, Column %d:%d",
			tokens[*index].Lexeme, tokens[*index].TokPos.Line, tokens[*index].TokPos.ColStart, tokens[*index].TokPos.ColEnd)
	}

	return valueNode, nil
}

// PrintAST prints the AST in a readable format
func PrintAST(node *ASTNode, indent string) {
	fmt.Printf("%sType: %s\n", indent, node.Type)
	if node.Value != nil {
		fmt.Printf("%sValue: %v\n", indent, node.Value)
		fmt.Printf("%s------------------------\n", indent)
	}
	for _, child := range node.Children {
		PrintAST(child, indent+"\t")
	}
}
